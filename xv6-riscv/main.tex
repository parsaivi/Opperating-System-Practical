
\section{گزارش پیاده‌سازی \lr{Lottery Scheduling} در \lr{xv6}}

\subsection{مقدمه}
در این تمرین، الگوریتم زمان‌بندی \lr{Lottery Scheduling} را برای سیستم‌عامل \lr{xv6} پیاده‌سازی کردیم. در این الگوریتم، به هر پردازه تعدادی بلیت (\lr{ticket}) اختصاص داده می‌شود و پردازنده با یک قرعه‌کشی تصادفی، پردازه‌ای را برای اجرا انتخاب می‌کند.

\subsection{مرحله ۱: اضافه کردن فیلد \lr{ticket} به ساختار پردازه}

\subsubsection{فایل: \lr{kernel/proc.h}}

فیلد \lr{ticket} را به \lr{struct proc} اضافه کردیم:

\begin{code}
struct proc {
  // ... سایر فیلدها ...
  char name[16];               // Process name (debugging)
  int ticket;                  // Lottery scheduling tickets
};
\end{code}

\subsection{مرحله ۲: مقداردهی اولیه \lr{ticket} و ارث‌بری در \lr{fork}}

\subsubsection{فایل: \lr{kernel/proc.c}}

۲.۱ مقداردهی اولیه در \lr{allocproc()}:
\begin{code}
// Initialize lottery ticket to default value (10)
p->ticket = 10;
\end{code}

۲.۲ ارث‌بری در \lr{kfork()}:
\begin{code}
// Inherit ticket count from parent
np->ticket = p->ticket;
\end{code}


\subsection{مرحله ۳: تغییر تابع \lr{scheduler} برای پیاده‌سازی \lr{Lottery Scheduling}}

\subsubsection{فایل: \lr{kernel/proc.c}}

الگوریتم جدید زمان‌بندی:

\begin{code}
void scheduler(void)
{
  struct proc *p;
  struct cpu *c = mycpu();

  c->proc = 0;
  for(;;){
    intr_on();
    intr_off();

    // Lottery Scheduling: count total tickets of RUNNABLE processes
    int total_tickets = 0;
    for(p = proc; p < &proc[NPROC]; p++) {
      acquire(&p->lock);
      if(p->state == RUNNABLE) {
        total_tickets += p->ticket;
      }
      release(&p->lock);
    }

    if(total_tickets == 0) {
      asm volatile("wfi");
      continue;
    }

    // Generate random winning ticket (ensure positive with & 0x7FFFFFFF)
    int winner = (rand_int() & 0x7FFFFFFF) % total_tickets;
    int counter = 0;

    for(p = proc; p < &proc[NPROC]; p++) {
      acquire(&p->lock);
      if(p->state == RUNNABLE) {
        counter += p->ticket;
        if(counter > winner) {
          // This process wins the lottery
          p->state = RUNNING;
          c->proc = p;
          swtch(&c->context, &p->context);
          c->proc = 0;
          release(&p->lock);
          break;
        }
      }
      release(&p->lock);
    }
  }
}
\end{code}

\subsubsection{توضیح الگوریتم:}
\begin{enumerate}
  \item ابتدا مجموع تمام بلیت‌های پردازه‌های \lr{RUNNABLE} را محاسبه می‌کنیم
  \item یک عدد تصادفی بین ۰ تا \lr{total\_tickets-1} تولید می‌کنیم
  \item با پیمایش پردازه‌ها و جمع کردن بلیت‌ها، پردازه برنده را پیدا می‌کنیم
  \item پردازه‌ای که بلیت بیشتری دارد، شانس بیشتری برای انتخاب دارد
\end{enumerate}


\subsection{مرحله ۴: اضافه کردن \lr{syscall} جدید \lr{settickets}}

\subsubsection{ فایل: \lr{kernel/syscall.h}}
\begin{code}
#define SYS_settickets 22
\end{code}

\subsubsection{ فایل: \lr{kernel/syscall.c}}
\begin{code}
extern uint64 sys_settickets(void);
// ...
[SYS_settickets] sys_settickets,
\end{code}

\subsubsection{ فایل: \lr{kernel/sysproc.c}}
\begin{code}
uint64 sys_settickets(void)
{
  int pid, tickets;
  
  argint(0, &pid);
  argint(1, &tickets);
  
  if(tickets <= 0)
    return -1;
  
  return settickets(pid, tickets);
}
\end{code}

\subsubsection{ فایل: \lr{kernel/proc.c}}
\begin{code}
int settickets(int pid, int tickets)
{
  struct proc *p;
  
  for(p = proc; p < &proc[NPROC]; p++){
    acquire(&p->lock);
    if(p->pid == pid){
      p->ticket = tickets;
      release(&p->lock);
      return 0;
    }
    release(&p->lock);
  }
  return -1;
}
\end{code}

\subsubsection{ فایل‌های \lr{user-space}:}
\begin{itemize}
  \item \lr{user/usys.pl}: اضافه کردن \lr{entry("settickets");}
  \item \lr{user/user.h}: اضافه کردن \lr{int settickets(int, int);}
\end{itemize}

\subsection{مرحله ۵: برنامه تست}

\subsubsection{فایل: \lr{user/lotterytest.c}}

\begin{code}
#include "kernel/types.h"
#include "kernel/stat.h"
#include "user/user.h"

#define LOOP_COUNT 100000000

int main(void)
{
  int pid1, pid2, pid3, pid4;
  int counter1 = 0, counter2 = 0, counter3 = 0, counter4 = 0;
  
  printf("Lottery Scheduling Test\n");
  printf("Creating 4 child processes with tickets: 10, 20, 30, 40\n\n");
  
  pid1 = fork();
  if(pid1 == 0) {
    settickets(getpid(), 10);
    for(int i = 0; i < LOOP_COUNT; i++) counter1++;
    printf("Child 1 (10 tickets): counter = %d\n", counter1);
    exit(0);
  }
  
  pid2 = fork();
  if(pid2 == 0) {
    settickets(getpid(), 20);
    for(int i = 0; i < LOOP_COUNT; i++) counter2++;
    printf("Child 2 (20 tickets): counter = %d\n", counter2);
    exit(0);
  }
  
  pid3 = fork();
  if(pid3 == 0) {
    settickets(getpid(), 30);
    for(int i = 0; i < LOOP_COUNT; i++) counter3++;
    printf("Child 3 (30 tickets): counter = %d\n", counter3);
    exit(0);
  }
  
  pid4 = fork();
  if(pid4 == 0) {
    settickets(getpid(), 40);
    for(int i = 0; i < LOOP_COUNT; i++) counter4++;
    printf("Child 4 (40 tickets): counter = %d\n", counter4);
    exit(0);
  }
  
  wait(0); wait(0); wait(0); wait(0);
  
  printf("\nTest completed!\n");
  printf("Expected ratio: 10:20:30:40 = 1:2:3:4\n");
  
  exit(0);
}
\end{code}

\subsection{نتیجه اجرا}

\subsubsection{دستورات اجرا:}
\begin{code}
make clean
make CPUS=1 qemu
\end{code}

در \lr{shell} \lr{xv6}:
\begin{code}
lotterytest
\end{code}

\subsubsection{خروجی نمونه:}
\begin{code}
\$ lotterytest
Lottery Scheduling Test
Tickets: 10, 20, 30, 40 (ratio 1:2:3:4)

Child 4 (40 tickets): 466837 iterations
Child 3 (30 tickets): 444985 iterations
Child 2 (20 tickets): 323828 iterations
Child 1 (10 tickets): 139893 iterations

Expected ratio: ~1:2:3:4 (10\%:20\%:30\%:40\%)
\end{code}

\subsubsection{تحلیل نتایج:}

\begin{table}[h]
\centering
\begin{tabular}{|c|c|c|c|c|}
\hline
پردازه & بلیت & \lr{Iterations} & درصد واقعی & درصد مورد انتظار \\
\hline
\lr{Child 1} & 10 & 139,893 & 10.2\% & 10\% \\
\hline
\lr{Child 2} & 20 & 323,828 & 23.5\% & 20\% \\
\hline
\lr{Child 3} & 30 & 444,985 & 32.4\% & 30\% \\
\hline
\lr{Child 4} & 40 & 466,837 & 33.9\% & 40\% \\
\hline
\end{tabular}
\end{table}

\textbf{نتیجه:} الگوریتم \lr{Lottery Scheduling} به درستی کار می‌کند:
\begin{itemize}
  \item پردازه با بلیت بیشتر (\lr{Child 4}) بیشترین زمان \lr{CPU} را دریافت کرده
  \item پردازه با بلیت کمتر (\lr{Child 1}) کمترین زمان \lr{CPU} را دریافت کرده
  \item نسبت تقریباً 1:2:3:4 رعایت شده است
\end{itemize}

\textbf{توجه:} از آنجا که \lr{Lottery Scheduling} یک الگوریتم احتمالی است، نتایج دقیقاً مطابق نسبت بلیت‌ها نیست، اما با افزایش زمان اجرا، نتایج به نسبت مورد انتظار نزدیک‌تر می‌شوند.

\includegraphics[scale=0.6]{images/qemu_out.png}



\subsubsection{فایل‌های تغییر یافته:}
\begin{enumerate}
  \item \lr{kernel/proc.h} - اضافه کردن فیلد \lr{ticket}
  \item \lr{kernel/proc.c} - \lr{allocproc}, \lr{kfork}, \lr{scheduler}, \lr{settickets}
  \item \lr{kernel/syscall.h} - شماره \lr{syscall} جدید
  \item \lr{kernel/syscall.c} - ثبت \lr{syscall}
  \item \lr{kernel/sysproc.c} - پیاده‌سازی \lr{sys\_settickets}
  \item \lr{kernel/defs.h} - \lr{declaration} تابع \lr{settickets}
  \item \lr{user/usys.pl} - \lr{stub} برای \lr{user-space}
  \item \lr{user/user.h} - \lr{declaration} برای \lr{user-space}
  \item \lr{user/lotterytest.c} - برنامه تست
  \item \lr{Makefile} - اضافه کردن \lr{lotterytest}
\end{enumerate}

همه این فایل‌ها در پوشه ارسالی قرار داده شده است.
